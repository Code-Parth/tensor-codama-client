/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type ReadonlyUint8Array,
} from "@solana/kit";
import {
  type ParsedBidInstruction,
  type ParsedCancelBidInstruction,
  type ParsedCloseExpiredBidInstruction,
  type ParsedTakeBidInstruction,
} from "../instructions";

export const TENSOR_BID_PROGRAM_ADDRESS = "" as Address<"">;

export enum TensorBidAccount {
  BidState,
}

export function identifyTensorBidAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): TensorBidAccount {
  const data = "data" in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([155, 197, 5, 97, 189, 60, 8, 183]),
      ),
      0,
    )
  ) {
    return TensorBidAccount.BidState;
  }
  throw new Error(
    "The provided account could not be identified as a tensorBid account.",
  );
}

export enum TensorBidInstruction {
  Bid,
  TakeBid,
  CancelBid,
  CloseExpiredBid,
}

export function identifyTensorBidInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): TensorBidInstruction {
  const data = "data" in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([199, 56, 85, 38, 146, 243, 37, 158]),
      ),
      0,
    )
  ) {
    return TensorBidInstruction.Bid;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([143, 227, 21, 28, 152, 128, 7, 10]),
      ),
      0,
    )
  ) {
    return TensorBidInstruction.TakeBid;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([40, 243, 190, 217, 208, 253, 86, 206]),
      ),
      0,
    )
  ) {
    return TensorBidInstruction.CancelBid;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([83, 20, 105, 67, 248, 68, 104, 190]),
      ),
      0,
    )
  ) {
    return TensorBidInstruction.CloseExpiredBid;
  }
  throw new Error(
    "The provided instruction could not be identified as a tensorBid instruction.",
  );
}

export type ParsedTensorBidInstruction<TProgram extends string = ""> =
  | ({
      instructionType: TensorBidInstruction.Bid;
    } & ParsedBidInstruction<TProgram>)
  | ({
      instructionType: TensorBidInstruction.TakeBid;
    } & ParsedTakeBidInstruction<TProgram>)
  | ({
      instructionType: TensorBidInstruction.CancelBid;
    } & ParsedCancelBidInstruction<TProgram>)
  | ({
      instructionType: TensorBidInstruction.CloseExpiredBid;
    } & ParsedCloseExpiredBidInstruction<TProgram>);
